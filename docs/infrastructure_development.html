<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/> 
    <title>IE BestBank - Infrastructure Development</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #f4f4f4;
        }
        header {
            background: #1E90FF;
            color: #fff;
            padding: 20px;
            text-align: center;
        }
        nav {
            display: flex;
            justify-content: center;
            background: #333;
        }
        nav a {
            color: #fff;
            text-decoration: none;
            padding: 14px 20px;
            display: inline-block;
        }
        nav a:hover {
            background: #1E90FF;
        }
        .content {
            max-width: 1200px;
            margin: 20px auto;
            background: #fff;
            padding: 20px;
            min-height: 600px;
        }
        h2 {
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }

        /* Tabs for Subsections */
        .subsection-tabs {
            margin-top: 40px;
        }

        .subsection-tabs input[type="radio"] {
            display: none;
        }

        .subsection-tabs label {
            display: inline-block;
            padding: 10px 20px;
            background: #ddd;
            margin: 0;
            cursor: pointer;
            border: 1px solid #ccc;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 4px;
        }

        .subsection-tabs label:hover {
            background: #ccc;
        }

        .subsection-tabs .tab-content {
            border: 1px solid #ccc;
            padding: 20px;
            background: #fff;
            display: none;
            border-radius: 0 5px 5px 5px;
        }

        #subtab1:checked ~ #content1,
        #subtab2:checked ~ #content2,
        #subtab3:checked ~ #content3 {
            display: block;
        }

        #subtab1:checked + label[for="subtab1"],
        #subtab2:checked + label[for="subtab2"],
        #subtab3:checked + label[for="subtab3"] {
            background: #fff;
            border-bottom: 1px solid #fff;
        }

        footer {
            text-align: center;
            font-size: 14px;
            color: #666;
            padding: 10px;
            margin-top: 40px;
        }
        hr {
            border: none;
            border-top: 3px solid #0e0d0d;
            margin: 40px 0; /* Add space before/after the line as needed */
        }
        code {
            background: #f4f4f4;
            padding: 2px 4px;
        }
        .img-container {
            text-align: center;
            margin: 40px 0;
        }

        .img-container img {
            max-width: 100%;
            height: 400px;
        }
    </style>
</head>
<body>
    <header>
        <h1>IE BestBank Documentation - Infrastructure Development</h1>
    </header>

    <nav>
        <a href="index.html">Home</a>
        <a href="product_owner.html">Product Owner</a>
        <a href="full_stack_development.html">Full Stack Development</a>
        <a href="infrastructure_development.html">Infrastructure Development</a>
        <a href="cyber_security.html">Cyber Security</a>
        <a href="site_reliability_engineering.html">Site Reliability Engineering</a>
        <a href="cloud_architecture_design.html">Cloud Architecture Design</a>
    </nav>

    <div class="content">
        <h2>Infrastructure Development Overview</h2>
        <p>
            This section covers infrastructure provisioning, configuration, and maintenance 
            guidelines within IE BestBank.
        </p>

        <div class="subsection-tabs">
            <input type="radio" name="subtabs" id="subtab1" checked>
            <label for="subtab1">Modularization Strategy</label>

            <input type="radio" name="subtabs" id="subtab2">
            <label for="subtab2">Environment Hosting Infrastructures</label>

            <input type="radio" name="subtabs" id="subtab3">
            <label for="subtab3">CI/CD and Release Strategy</label>

            <div class="tab-content" id="content1">
                <h3>Modularization Strategy</h3>
                <p>
                    A modularization strategy for the Infrastructure as Code (IaC) was adopted to align with best practices 
                    in modern cloud architecture. This decision was taken to ensure:
                </p>
                <ul>
                    <li><strong>Maintainability:</strong> Breaking down the code into smaller, well-defined modules ensures that updates or changes 
                        can be made to individual components without impacting the entire system.</li>
                    <li><strong>Reusability:</strong> Each module can be reused across different environments (e.g., Development, UAT, Production) 
                        or projects, reducing redundancy and improving consistency.</li>
                    <li><strong>Scalability:</strong> Modular design makes it easier to add new features or components as the infrastructure evolves, 
                        without requiring major overhauls to the existing codebase.</li>
                    <li><strong>Testability:</strong> Isolated modules allow for targeted testing of specific resources or configurations, ensuring 
                        each component meets the required standards.</li>
                    <li><strong>Flexibility:</strong> The strategy provides the ability to customize specific modules for different use cases while 
                        maintaining a unified and coherent codebase.</li>
                </ul>
                <hr>
                <h3>Implementation of Modularization</h3>
                <p>
                    The adopted modularization strategy for the infrastructure includes a component-based modularization approach. 
                    This ensures that each infrastructure resource or logical grouping of resources is encapsulated into individual Bicep modules.
                </p>
                <p>This modular strategy focuses on:</p>

                <h4>1. Separation of Concerns</h4>
                <ul>
                    <li>
                        Each module is designed to manage a specific infrastructure component (Key Vault, App Service Plan, Application Insights, 
                        Log Analytics, Container Registry, Database, Server, Static Web App, App Service) independently, aligning with the principle 
                        of single responsibility.
                    </li>
                </ul>

                <h4>2. Parameterization</h4>
                <ul>
                    <li>
                        Modules are designed to be flexible by accepting parameters for customization (e.g., resource names, role assignments, SKUs). 
                        This ensures modules can be reused across multiple environments (Development, UAT, Production) with different configurations.
                        This allows for high scalability and flexibility by...
                    </li>
                </ul>

                <h4>3. Standardized Outputs</h4>
                <ul>
                    <li>
                        Modules provide outputs such as resource IDs, which can be consumed by other modules or higher-level orchestration files, 
                        enabling seamless integration and reducing duplication.
                    </li>
                </ul>

                <h4>4. Environment-Specific Deployments</h4>
                <ul>
                    <li>
                        Environment-specific parameter files are utilized (<code>dev.bicepparam</code>, <code>uat.bicepparam</code>, 
                        <code>prod.bicepparam</code>) to set the appropriate configurations for each module in the different environments, 
                        and allow for easy distinction between them.
                    </li>
                    <li>
                        It also allows for very easy scalability. For instance, if a fourth environment is created solely for testing, 
                        it will be easy to configure all the parameters for that environment without touching any of the other files, 
                        simply by creating a new <code>test.bicepparam</code> file.
                    </li>
                </ul>

                <h4>5. Encapsulation and Independence</h4>
                <ul>
                    <li>
                        Each module is self-contained, meaning changes to one module (e.g., updating the Key Vault) do not require changes 
                        in other modules, unless explicitly dependent.
                    </li>
                </ul>

                <hr>
                <h3>Resources Used and Their Roles</h3>
                <ol>
                    <li>
                        <strong>Containerize the Backend:</strong> We decided to containerize the backend because containerization ensures consistency across different environments, makes scaling and deployment easier, and allows for rapid, reliable updates. By packaging the application and its dependencies into a container, we streamline CI/CD processes and improve portability across development, staging, and production environments.
                    </li>
                    <li>
                        <strong>App Service Plan (Backend Only):</strong> We decided to use 1 App Service Plan only for the backend since static web apps do not require app service plans. The purpose of the app service plan is to provide the necessary compute resources for our containerized backend, ensuring performance, scaling capabilities, and predictable resource allocation.
                    </li>
                    <li>
                        <strong>Static Web App (Frontend):</strong> We chose a static web app for the frontend because static web apps offer a fully managed hosting service optimized for static content and front-end frameworks. They are cost-effective, provide integrated CI/CD support, scale automatically, and do not require an App Service Plan. This approach simplifies the frontend deployment process and ensures seamless user experiences even under fluctuating traffic.
                    </li>
                    <li>
                        <strong>Separate Modules for Database and Server:</strong> We decided to have separate modules for the database and the server for scalability, maintainability, and clear separation of concerns. By isolating these components, changes to one do not affect the other, making it easier to scale, replace, or upgrade individual parts of the infrastructure without impacting the entire system.
                    </li>
                    <li>
                        <strong>Log Analytics:</strong> Used for monitoring the Azure resources, collecting and aggregating logs and metrics in a centralized workspace. This enhances observability and makes troubleshooting more efficient.
                    </li>
                    <li>
                        <strong>Application Insights:</strong> Used for monitoring both the frontend and backend, providing performance metrics, request traces, and other telemetry data that help in diagnosing issues and optimizing the application experience.
                    </li>
                    <li>
                        <strong>Key Vault:</strong> Stores sensitive information such as container registry credentials and the static web app token securely. It ensures that these secrets are managed and accessed safely, adhering to security best practices.
                    </li>
                    <li>
                        <strong>Container Registry:</strong> Used to push and store container images that the backend App Service will run. This ensures a secure and reliable method of distributing application artifacts to the runtime environment.
                    </li>
                </ol>
                <hr>
                <h3>Detailed Connections and Dependencies</h3>
                <p>
                    The <code>main.bicep</code> file orchestrates all the resources in the correct order. 
                    It ensures that outputs from one module are used as inputs in subsequent modules, establishing clear dependencies:
                </p>

                <h4>Step 1: Log Analytics Workspace</h4>
                <ul>
                    <li><strong>Output:</strong> <code>logAnalyticsWorkspaceId</code></li>
                    <li>
                        This ID is critical for enabling diagnostic settings in other resources:
                        <ul>
                            <li>Key Vault: For logging activities.</li>
                            <li>App Service (backend): For application diagnostics.</li>
                            <li>PostgreSQL Server: For monitoring and diagnostics.</li>
                        </ul>
                    </li>
                    <li><strong>Why:</strong> Centralizing logs and telemetry enhances observability and troubleshooting.</li>
                </ul>

                <h4>Step 2: Application Insights</h4>
                <ul>
                    <li><strong>Input:</strong> <code>logAnalyticsWorkspaceId</code> (from Log Analytics)</li>
                    <li><strong>Outputs:</strong>
                        <ul>
                            <li><code>connectionString</code>: Used by backend App Service for telemetry.</li>
                            <li><code>instrumentationKey</code>: Used to track backend and frontend application metrics.</li>
                        </ul>
                    </li>
                    <li><strong>Why:</strong> Application Insights integrates with Log Analytics to provide performance monitoring, enabling developers to track app health and usage patterns.</li>
                </ul>

                <h4>Step 3: Key Vault</h4>
                <ul>
                    <li><strong>Input:</strong> <code>logAnalyticsWorkspaceId</code> (for diagnostic settings)</li>
                    <li><strong>Output:</strong> <code>resourceId</code>
                        <ul>
                            <li>Used by the Container Registry, Static Web App, and other modules to configure secrets or secure access.</li>
                        </ul>
                    </li>
                    <li><strong>Why:</strong> Secure storage of sensitive information like credentials ensures compliance with security best practices.</li>
                </ul>

                <h4>Step 4: Container Registry</h4>
                <ul>
                    <li><strong>Inputs:</strong> <code>logAnalyticsWorkspaceId</code> (for diagnostics), <code>keyVaultResourceId</code> (for secure admin credentials)</li>
                    <li><strong>Dependencies:</strong> Key Vault</li>
                    <li><strong>Why:</strong> Secure container image management with diagnostics ensures that only authorized components can access the registry.</li>
                </ul>

                <h4>Step 5: App Service Plan</h4>
                <ul>
                    <li><strong>Output:</strong> <code>appServicePlanId</code></li>
                    <li><strong>Consumed by:</strong> App Service (backend)</li>
                    <li><strong>Why:</strong> Defines the hosting environment for the backend service, including scaling and SKU configuration.</li>
                </ul>

                <h4>Step 6: App Service (Backend)</h4>
                <ul>
                    <li><strong>Inputs:</strong>
                        <ul>
                            <li><code>logAnalyticsWorkspaceId</code>: For diagnostics.</li>
                            <li><code>appServicePlanId</code>: Hosting the backend service.</li>
                            <li><code>keyVaultReference</code>: Retrieve Docker registry credentials from Key Vault.</li>
                            <li><code>appInsights.connectionString</code>: For telemetry integration.</li>
                        </ul>
                    </li>
                    <li><strong>Dependencies:</strong> Key Vault, Container Registry, App Service Plan</li>
                    <li><strong>Why:</strong> The backend requires multiple integrations (container images, telemetry, secure credentials) to operate effectively.</li>
                </ul>

                <h4>Step 7: PostgreSQL Server</h4>
                <ul>
                    <li><strong>Inputs:</strong> <code>logAnalyticsWorkspaceId</code> for diagnostics, <code>appServiceWebsiteBE.outputs.systemAssignedIdentityPrincipalId</code> for RBAC with the backend.</li>
                    <li><strong>Dependencies:</strong> Backend App Service</li>
                    <li><strong>Why:</strong> Tight integration with the backend ensures secure, identity-based access to the database.</li>
                </ul>

                <h4>Step 8: PostgreSQL Database</h4>
                <ul>
                    <li><strong>Input:</strong> <code>postgreSQLServerName</code> to link the database with the server.</li>
                    <li><strong>Dependencies:</strong> PostgreSQL Server</li>
                    <li><strong>Why:</strong> A consistent, structured database setup avoids configuration mismatches.</li>
                </ul>

                <h4>Step 9: Static Web App</h4>
                <ul>
                    <li><strong>Input:</strong> <code>keyVaultResourceId</code> to securely retrieve the SWA token.</li>
                    <li><strong>Dependencies:</strong> Key Vault</li>
                    <li><strong>Why:</strong> Ensures that the frontend can interact securely with other services and maintain secure operations.</li>
                </ul>
                <hr>
                <h3>Why This Approach Works</h3>
                <ul>
                    <li><strong>Centralized Logging and Telemetry:</strong> Using Log Analytics and Application Insights provides a unified diagnostics and monitoring framework.</li>
                    <li><strong>Security via Key Vault:</strong> Centralized management of sensitive credentials minimizes risk and adheres to security best practices.</li>
                    <li><strong>Dynamic Resource Sharing:</strong> Outputs like resource IDs and connection strings enable seamless integration between modules without hardcoding.</li>
                    <li><strong>Dependency Management:</strong> <code>dependsOn</code> clauses ensure resources are deployed in the correct order, avoiding deployment failures.</li>
                    <li><strong>Flexibility and Scalability:</strong> Adding or modifying modules is straightforward since each module is self-contained.</li>
                </ul>

                <hr>
                <p>
                    <strong>The Azure Verified Modules were leveraged in order to develop the IAC modules to
                    ensure seamless use of the necessary configurations.</strong>
                </p>

            </div>

            <div class="tab-content" id="content2">
                <h3>Environment Hosting Infrastructures</h3>
                <p>
                    The configurations of each module, used across all 3 environments (Development, UAT, and Production), include:
                </p>
            
                <h3>1. Application Insights</h3>
                <ul>
                    <li><strong>Parameters:</strong></li>
                    <ul>
                        <li><strong>location:</strong> Ensures the App Insights resource is deployed in the same region as other resources to reduce latency and improve performance.</li>
                        <li><strong>WorkspaceResourceId:</strong> Links App Insights to our Log Analytics Workspace for centralized monitoring and telemetry data storage.</li>
                        <li><strong>name:</strong> A unique and easily identifiable name for our App Insights resource.</li>
                        <li><strong>applicationType:</strong> Specifies the type of application (e.g., web), optimizing monitoring configuration for our application.</li>
                        <li><strong>retentionInDays:</strong> Sets telemetry retention (90 days) to balance troubleshooting data availability and cost.</li>
                    </ul>
                </ul>
            
                <h3>2. Log Analytics</h3>
                <ul>
                    <li><strong>Parameters:</strong></li>
                    <ul>
                        <li><strong>name:</strong> Identifies the Log Analytics Workspace in our deployment.</li>
                        <li><strong>location:</strong> Aligns the workspace with other resources for consistent performance and minimal latency.</li>
                        <li><strong>skuName:</strong> Defines the pricing tier (e.g., PerGB2018) to optimize costs for our environment.</li>
                        <li><strong>dataRetention:</strong> Retains logs for 30 days, providing sufficient recent data for analysis without unnecessary cost.</li>
                    </ul>
                </ul>
            
                <h3>3. App Service (Backend)</h3>
                <ul>
                    <li><strong>Parameters:</strong></li>
                    <ul>
                        <li><strong>location:</strong> Deploys the App Service close to other resources for better performance.</li>
                        <li><strong>name:</strong> Unique name for easy identification in Azure.</li>
                        <li><strong>appServicePlanId:</strong> Links the App Service to an App Service Plan for hosting and scaling.</li>
                        <li><strong>dockerRegistryName:</strong> Points to the Azure Container Registry storing backend images.</li>
                        <li><strong>dockerRegistryServerUserName & dockerRegistryServerPassword:</strong> Credentials for authenticating with the Container Registry.</li>
                        <li><strong>dockerRegistryImageName & dockerRegistryImageVersion:</strong> Specifies which backend container image and version to deploy.</li>
                        <li><strong>WorkspaceResourceId:</strong> Connects the App Service to Log Analytics for logs and metrics.</li>
                        <li><strong>instrumentationKey & connectionString:</strong> Enables integration with App Insights for telemetry.</li>
                        <li><strong>adminUsername & adminPassword:</strong> Configures secure admin credentials for managing the backend.</li>
                    </ul>
                </ul>
            
                <h3>4. App Service Plan</h3>
                <ul>
                    <li><strong>Parameters:</strong></li>
                    <ul>
                        <li><strong>location:</strong> Aligns the App Service Plan region with the App Service and other resources.</li>
                        <li><strong>appServicePlanName:</strong> A distinct name for easy identification.</li>
                        <li><strong>sku:</strong> Defines the pricing tier (e.g., B1 or F1) to balance cost and performance.</li>
                    </ul>
                </ul>
            
                <h3>5. Container Registry</h3>
                <ul>
                    <li><strong>Parameters:</strong></li>
                    <ul>
                        <li><strong>name:</strong> Unique name for the Azure Container Registry (ACR).</li>
                        <li><strong>location:</strong> Keeps the ACR in the same region as other resources.</li>
                        <li><strong>keyVaultResourceId:</strong> Links ACR to Key Vault for secure admin credential storage.</li>
                        <li><strong>keyVaultSecreNameAdminUsername & keyVaultSecreNameAdminPassword0/1:</strong> Names for ACR admin credentials in Key Vault.</li>
                        <li><strong>sku:</strong> Determines the ACR pricing tier based on workload requirements.</li>
                    </ul>
                </ul>
            
                <h3>6. Database (PostgreSQL Database)</h3>
                <ul>
                    <li><strong>Parameters:</strong></li>
                    <ul>
                        <li><strong>postgreSQLDatabaseName:</strong> Identifies the PostgreSQL database.</li>
                        <li><strong>serverName:</strong> Links the database to the existing PostgreSQL server.</li>
                    </ul>
                </ul>
            
                <h3>7. Key Vault</h3>
                <ul>
                    <li><strong>Parameters:</strong></li>
                    <ul>
                        <li><strong>name:</strong> Globally unique Key Vault name.</li>
                        <li><strong>enableRbacAuthorization:</strong> Enables Role-Based Access Control for secure, flexible permissions.</li>
                        <li><strong>enableVaultForDeployment & enableVaultForTemplateDeployment:</strong> Allows scripts and templates to access secrets during deployments.</li>
                        <li><strong>enableSoftDelete:</strong> Controls secret recovery. Set to false in Dev (due to nightly deletions) and true in UAT and Prod for enhanced safety.</li>
                        <li><strong>sku:</strong> Standard or Premium tier based on environment.</li>
                        <li><strong>roleAssignments:</strong> Assigns roles to users or service principals for secure Key Vault access.</li>
                    </ul>
                </ul>
            
                <h3>8. PostgreSQL Server</h3>
                <ul>
                    <li><strong>Parameters:</strong></li>
                    <ul>
                        <li><strong>location:</strong> Aligns the server’s region with other resources.</li>
                        <li><strong>name:</strong> Names the PostgreSQL server for easy identification.</li>
                        <li><strong>postgreSQLAdminServicePrincipalObjectId & postgreSQLAdminServicePrincipalName:</strong> Configures a service principal for RBAC-based server management.</li>
                        <li><strong>skuName & tier:</strong> Balances performance and cost according to environment needs.</li>
                    </ul>
                </ul>
            
                <h3>9. Static Web App</h3>
                <ul>
                    <li><strong>Parameters:</strong></li>
                    <ul>
                        <li><strong>name:</strong> Names the Static Web App for easy identification.</li>
                        <li><strong>sku:</strong> Chooses a service tier (Free or Standard) based on environment requirements.</li>
                        <li><strong>location:</strong> Keeps the Static Web App in the same region as other resources.</li>
                        <li><strong>keyVaultResourceId:</strong> Links to Key Vault to securely store the deployment token.</li>
                        <li><strong>keyVaultSecretName:</strong> Specifies the Key Vault secret name for the deployment token.</li>
                    </ul>
                </ul>
            
                <h3>Differences Between Environments</h3>
                <p>
                    The general configurations that differ between the three environments include:
                </p>
                <ul>
                    <li><strong>Resource Names:</strong> Key Vault name, Container Registry name, PostgreSQL server name, PostgreSQL database name, App Service Plan name, Backend App Service name, Static Web App name, Log Analytics Workspace name, App Insights name.</li>
                    <li><strong>Key Vault Soft Delete:</strong> 
                        <ul>
                            <li>Dev: false (due to nightly deletions)</li>
                            <li>UAT: true (mimicking production behavior for testing)</li>
                            <li>Prod: true (stable environment with no nightly deletions)</li>
                        </ul>
                    </li>
                    <li><strong>SKUs:</strong> Different pricing tiers chosen based on environment needs to optimize cost and performance.</li>
                    <li><strong>Key Vault Role Assignment:</strong> 
                        <ul>
                            <li>Only the service principal is given user access in both production and UAT for security.</li>
                            <li>In UAT, the group is given Key Vault administrator access to verify functionality before applying similar settings in production.</li>
                        </ul>
                    </li>
                    <li><strong>Container Registry Naming Convention:</strong> Using <code>LikeThisFormat</code> instead of <code>like-this-format</code> due to Azure restrictions on hyphenated formats.</li>
                </ul>
            
                <p>
                    Overall, differing SKUs and configurations across environments allow for cost efficiency and the ability to test changes before moving them into a production environment. This modular and strategic approach ensures functionality, scalability, and robust infrastructure management tailored to each stage of the development lifecycle.
                </p>
                <hr>

                <h3>Development Environment (Dev)</h3>
                <div class="img-container">
                    <img src="../images/dev.png" alt="Development Infrastructure">
                </div>
                <h4>SKUs:</h4>
                <ol>
                    <li><strong>Key Vault: Standard</strong><br>
                        <em>Reason:</em> Offers RBAC integration and diagnostic logging, essential even in Dev for realistic testing scenarios.</li>
                    <li><strong>Azure Container Registry (ACR): Basic</strong><br>
                        <em>Reason:</em> Sufficient for storing Docker images for development without requiring premium features.</li>
                    <li><strong>PostgreSQL Server: Standard_B1ms (Burstable Tier)</strong><br>
                        <em>Reason:</em> Cost-effective and simulates real-world scenarios without over-provisioning.</li>
                    <li><strong>App Service Plan: F1 (Free Tier)</strong><br>
                        <em>Reason:</em> Dev workloads are light; free resources suffice to test functionality.</li>
                    <li><strong>Static Web App: Free</strong><br>
                        <em>Reason:</em> Testing frontend functionality doesn’t require advanced features.</li>
                    <li><strong>Log Analytics Workspace: PerGB2018</strong><br>
                        <em>Reason:</em> Ensures diagnostic data retention and scalability; supported across environments.</li>
                    <li><strong>Application Insights: 90-day Retention</strong><br>
                        <em>Reason:</em> Longer retention for thorough performance testing and debugging in Dev.</li>
                </ol>
                <hr>

                <h3>User Acceptance Testing Environment (UAT)</h3>
                <div class="img-container">
                    <img src="../images/uat.png" alt="UAT Infrastructure">
                </div>
                <h4>SKUs:</h4>
                <ol>
                    <li><strong>Key Vault: Standard</strong><br>
                        <em>Reason:</em> Mirrors production environment to validate configurations work as expected.</li>
                    <li><strong>ACR: Basic</strong><br>
                        <em>Reason:</em> Similar to Dev; adequate for testing limited image storage needs.</li>
                    <li><strong>PostgreSQL Server: Standard_B1ms</strong><br>
                        <em>Reason:</em> Handles real-world usage simulations without high costs.</li>
                    <li><strong>App Service Plan: F1 (Free Tier)</strong><br>
                        <em>Reason:</em> UAT focuses on behavior testing, not heavy traffic, so free is sufficient.</li>
                    <li><strong>Static Web App: Free</strong><br>
                        <em>Reason:</em> No need for production-grade scalability during UAT.</li>
                    <li><strong>Log Analytics Workspace: PerGB2018</strong><br>
                        <em>Reason:</em> Consistent SKU across all environments for unified diagnostics.</li>
                    <li><strong>Application Insights: 90-day Retention</strong><br>
                        <em>Reason:</em> Maintains retention for debugging and monitoring over UAT’s testing period.</li>
                </ol>
                <hr>

                <h3>Production Environment (Prod)</h3>
                <div class="img-container">
                    <img src="../images/prod.png" alt="Production Infrastructure">
                </div>
                <h4>SKUs:</h4>
                <ol>
                    <li><strong>Key Vault: Standard</strong><br>
                        <em>Reason:</em> Offers RBAC and geo-redundancy for compliance and high availability.</li>
                    <li><strong>ACR: Standard</strong><br>
                        <em>Reason:</em> Faster performance, more storage, and geo-replication for production workloads.</li>
                    <li><strong>PostgreSQL Server: Standard_B1ms</strong><br>
                        <em>Reason:</em> Balances cost and performance for workloads with intermittent bursts.</li>
                    <li><strong>App Service Plan: B1 (Basic Tier)</strong><br>
                        <em>Reason:</em> Supports higher traffic and production-grade workloads than F1.</li>
                    <li><strong>Static Web App: Standard</strong><br>
                        <em>Reason:</em> Enables custom domains, scaling, and better performance for production frontend.</li>
                    <li><strong>Log Analytics Workspace: PerGB2018</strong><br>
                        <em>Reason:</em> Full diagnostic support and compatibility across environments.</li>
                    <li><strong>Application Insights: 90-day Retention</strong><br>
                        <em>Reason:</em> Sufficient telemetry data for long-term trends and live environment debugging.</li>
                </ol>
                <hr>

                <h3>Design Decisions and Justifications</h3>
                <h4>1. Free and Basic SKUs in Dev and UAT</h4>
                <p><em>Reasoning:</em> Testing environments don’t need full scalability or performance. Using free and basic tiers optimizes costs while still enabling thorough testing.</p>
                <p><em>Example:</em> F1 (Free) App Service Plan in Dev/UAT to test applications without incurring unnecessary costs.</p>

                <hr>
                <h4>2. Unified SKU for Log Analytics</h4>
                <p><em>Reasoning:</em> PerGB2018 SKU works across all environments, simplifying configuration and providing consistent diagnostic capabilities.</p>

                <hr>
                <h4>3. Upgrade to Production-Grade SKUs</h4>
                <p><em>Reasoning:</em> In Production, tiers ensure performance, scalability, and reliability.</p>
                <p><em>Example:</em> Upgrading the Static Web App to Standard for features like custom domains and scaling, essential in a production-grade application.</p>

                <hr>
                <h4>4. Consistent Key Vault SKU Across Environments</h4>
                <p><em>Reasoning:</em> Uniform security features and diagnostic settings across Dev, UAT, and Prod ensure consistent testing and deployment pipelines.</p>

                <hr>
                <h3>Why Free SKUs in Production?</h3>
                <p><em>Reason:</em> Some features don’t require higher-tier SKUs. Retaining a 90-day retention period for Application Insights in Production remains cost-efficient while still providing sufficient telemetry data for monitoring and debugging.</p>


            </div>

            <div class="tab-content" id="content3">
                <h3>CI/CD and Release Strategy</h3>
                <p>
                    Our Continuous Integration (CI) pipeline is designed to ensure high-quality infrastructure code 
                    by automating the testing and validation of Bicep templates at every stage of development.
                </p>
                <hr>
                <h3>Key Aspects of the CI Pipeline</h3>
                <ol>
                    <li><strong>Automated Linting and Syntax Validation:</strong>
                        <ul>
                            <li>The pipeline uses <code>az bicep build</code> to validate the syntax and structure of all Bicep files.</li>
                            <li>This ensures code changes comply with best practices and will compile without errors.</li>
                        </ul>
                    </li>
                    <li><strong>Dry-Run Validation (What-if Analysis):</strong>
                        <ul>
                            <li>The CI pipeline includes a dry-run step (<code>az deployment group what-if</code>) to simulate infrastructure deployments.</li>
                            <li>This identifies unintended resource changes or conflicts without making actual changes.</li>
                        </ul>
                    </li>
                    <li><strong>Pull Request Integration:</strong>
                        <ul>
                            <li>Pull requests targeting the main branch automatically trigger CI workflows.</li>
                            <li>All proposed changes are validated before being merged into the primary branch.</li>
                        </ul>
                    </li>
                    <li><strong>Key Vault Module Unit Testing:</strong>
                        <ul>
                            <li>A dedicated <code>testing.yml</code> workflow deploys a temporary Key Vault to validate secrets, role assignments, and diagnostic settings.</li>
                            <li>This prevents misconfigurations from affecting live environments.</li>
                        </ul>
                    </li>
                </ol>
            
                <hr>
                <h3>Continuous Delivery (CD)</h3>
                <p>
                    The Continuous Delivery (CD) pipeline automates the deployment of infrastructure across multiple environments, 
                    enabling a smooth and reliable transition from development to production.
                </p>
            
                <h3>Key Aspects of the CD Pipeline</h3>
                <ol>
                    <li><strong>Environment-Specific Deployments:</strong>
                        <ul>
                            <li>Separate stages for Development, UAT, and Production ensure controlled and isolated deployments.</li>
                            <li>Each environment uses parameterized configurations (<code>dev.bicepparam</code>, <code>uat.bicepparam</code>, <code>prod.bicepparam</code>) 
                                to customize deployments while maintaining consistency.</li>
                        </ul>
                    </li>
                    <li><strong>Progressive Deployment Workflow:</strong>
                        <ul>
                            <li><strong>Development:</strong> Initial deployment for testing and validation.</li>
                            <li><strong>UAT:</strong> Testing in a staging environment that mirrors production settings.</li>
                            <li><strong>Production:</strong> Final deployment after successful validation in UAT.</li>
                        </ul>
                    </li>
                    <li><strong>Dependency Management:</strong>
                        <ul>
                            <li>The pipeline uses the <code>needs</code> keyword to ensure sequential deployment across environments, preventing premature deployments.</li>
                        </ul>
                    </li>
                    <li><strong>Secrets Management:</strong>
                        <ul>
                            <li>Sensitive information like credentials and tokens is securely injected at runtime using GitHub Secrets and Azure Key Vault.</li>
                        </ul>
                    </li>
                    <li><strong>Full Automation:</strong>
                        <ul>
                            <li>Each deployment is triggered automatically based on changes to the main branch or upon a workflow dispatch event, minimizing manual intervention.</li>
                        </ul>
                    </li>
                </ol>
            
                <hr>
                <h3>Release Strategy</h3>
                <p>
                    The release strategy ensures that infrastructure changes are deployed progressively, securely, and with minimal risk.
                </p>
            

                <h3>Key Elements of the Release Strategy</h3>
                <ul>
                    <li><strong>Multi-Stage Deployment:</strong>
                        <ul>
                            <li>Infrastructure is deployed to Development, UAT, and Production environments in separate stages.</li>
                            <li>Issues can be identified and resolved early in lower environments before reaching production.</li>
                        </ul>
                    </li>
                    <li><strong>Conditional Triggers:</strong>
                        <ul>
                            <li>Deployment to UAT and Production is triggered only after successful completion of the preceding stages.</li>
                            <li>Deployment to Production is restricted to changes made to the main branch, ensuring only validated code is released.</li>
                        </ul>
                    </li>
                    <li><strong>Testing in Isolation:</strong>
                        <ul>
                            <li>Temporary resources, such as a test Key Vault, are deployed during CI to validate configurations without impacting live resources.</li>
                        </ul>
                    </li>
                    <li><strong>Observability and Monitoring:</strong>
                        <ul>
                            <li>Diagnostic settings and telemetry are configured for all resources, integrating with Log Analytics and Application Insights.</li>
                            <li>This ensures visibility into deployments and resource health across all environments.</li>
                        </ul>
                    </li>
                    <li><strong>Security by Design:</strong>
                        <ul>
                            <li>All sensitive information is managed securely using Azure Key Vault and GitHub Secrets, adhering to security best practices.</li>
                        </ul>
                    </li>
                    <li><strong>Rollback and Recovery:</strong>
                        <ul>
                            <li>The modular nature of the infrastructure allows for targeted rollback of specific resources in case of failure.</li>
                            <li>Version control makes it easier to revert to previous stable configurations if needed.</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </div>

    <footer>
        &copy; 2024 IE BestBank. All rights reserved.
    </footer>
</body>
</html>
